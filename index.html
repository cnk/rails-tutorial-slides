<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-US">
  <head>
    <meta name="generator" content="HTML Tidy for Linux/x86 (vers 1st November 2003), see www.w3.org" />
    <title>Rails Tutorial Using Rails 3.0.10</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="copyright" content="Copyright &#169; 2011 The Rubyists http://therubyists.org" />
    <meta name="duration" content="20" />
    <link rel="stylesheet" href="http://www.w3.org/Talks/Tools/Slidy2/styles/slidy.css" type="text/css" />
    <script src="http://www.w3.org/Talks/Tools/Slidy2/scripts/slidy.js" charset="utf-8" type="text/javascript"></script>
  </head>
  <body>
    <div class="slide">
      <h1>Welcome</h1>

      <p>
        Welcome to the LA Ruby Study Group Rails Tutorial Workshop.
      </p>

      <p>
        We are going to work through the Rails Tutorial book. You will
        have already worked through the install steps last
        weekend. Tonight we will be starting right in with Chapter 3 -
        Mostly Static Pages.
      </p>
      
      <p>
        We will be skipping the testing portions of the book. In the
        long run, testing saves time you would spend debugging or
        doing <i>ad hoc</i> testing - but in the short run it takes
        time.
      </p>

    </div>

    <div class="slide">
      <h1>Our Sample App</h1>

      <pre>
  cd _wherever_you_want_to_work_
  rails new sample_app

  app/   - this is where your application lives
     controllers/
     helpers/
     models/
     views/
  config/  - application configuration, e.g. database.yml
  db/migrations/ - database-agnostic schema definition
  log/     - log files. Look here for debugging information
  public/  - images, stylesheets, javascript
  Gemfile  - what gems should we load for this application? 
  .gitignore -  Lists of files we don't want version controlled      </pre>
    </div>

    <div class="slide">
      <h1>Start Your Server</h1>

      <pre>
  cd sample_app
  bundle install
  rails server	
  => Booting WEBrick
  => Rails 3.0.9 application starting on http://0.0.0.0:3000
  => Call with -d to detach
  => Ctrl-C to shutdown server      </pre>

      <p>
        In your web browser, got to <a href="http://localhost:3000">http://localhost:3000</a>
      </p>
    </div>

    <div class="slide">
      <h1>Using Git</h1>

      <p>
        Version control is a good development practice. It is also the
        tool we are going to use to transfer the code you have on your
        local machine to Heroku - a web host where the rest of the
        world can see your handiwork. 
      </p>

      <pre>
  Initial (one time) setup: 
  git config --global user.name "Your Name"
  git config --global user.name "Your Name"

  git init
  # Possibly edit the .gitignore file
  git add . 
  git commit -m "Bare rails project"      </pre>
    </div>

    <div class="slide">
      <h1>Deploy</h1>

      <p>
        Everyone signed up for a free Heroku account, right? <a
        href="https://api.heroku.com/signup">https://api.heroku.com/signup</a> 
      </p>

      <pre>
  gem list heroku

  heroku keys:add
  heroku create
  git push heroku master

  heroku open      </pre>
      <p>
        Don't worry about the fact the "About your application's
        environment" link doesn't work on Heroku. That's normal. We'll
        be replacing that page with something more interesting soon.
      </p>
    </div>

    <div class="slide">
      <h1>Static Pages</h1>

      <p>
        Any page or file placed within the public/ directory will be
        served directly from that location without passing through the
        rails routing system. For example, let's create a file
        public/hello.html
     </p>

     <p>
       That's nice. But it has all the disadvantages of a static web
       page. For example, it must contain all of the styling
       information for the page. And if that changes, it needs to be
       changed on every page. That violates one of Rails' guiding
       principles: <b>Don't Repeat Yourself</b>
     </p>

      <p>
        Rails can offer you a better option - using the Rails
        templating system to apply a common layout. 
      </p>
    </div>

    <div class="slide">
      <h1>Not Really Static Pages</h1>

      <pre>
  rails generate controller Pages home contact      
      create  app/controllers/pages_controller.rb
       route  get "pages/contact"
       route  get "pages/home"
      invoke  erb
      create    app/views/pages
      create    app/views/pages/home.html.erb
      create    app/views/pages/contact.html.erb      </pre>

      <p>
        This will have generated a controller named Pages and added 2
        actions to it: home and contact. It has also added routes and pages.
	Let's look at them.
      </p>
    </div>

    <div class="slide">
      <h1>Common Layout</h1>

      <p>
        Let's take advantage of the site layout file. Let's add a
        title to each page.
      </p>

      <pre>
  class PagesController < ApplicationController
    def home
      @title = "Home"
    end
  end      </pre>

      <p>
        Views: html + ruby. The text between &lt;% and %&gt; is
        evaluated as ruby. If there is an equal sign, the result of
        the ruby is placed in the html:  &lt;%= 2+2 %&gt; yields
        4. The value of instance variables can be placed in a view.
      </p>

      <pre>
  &lt;title&gt;&lt;%= @title %&gt;&lt;/title&gt;     </pre>
    </div>

    <div class="slide">
      <h1>A Sliver of Ruby</h1>

      <pre>
  module ApplicationHelper

    # Return a title on a per-page basis.
    def title
      base_title = "Ruby on Rails Tutorial Sample App"
      if @title.nil?
	base_title
      else
	"#{base_title} | #{@title}"
      end
    end
  end  </pre>

      <ul>
        <li>How to define methods, variables, and comments</li>
        <li>if-else-end syntax</li>
	<li>foo.nil?  (Rails also gives you foo.blank?)</li>
	<li>String interpolation: "#{variable} plus litteral text"
	<li>Application Helper methods are available in all views on
        your site</li>
      </ul>
    </div>

    <div class="slide">
      <h1>A Bit More Ruby</h1>

      <pre>
  # Array's 
  a = [23, 43, "foo", "zombies"]
  puts a[0] 
  => 23
  a.length 
  => 4

  # Hashes
  user = { "first_name" => "Michael", "last_name" => "Hartl" }
  user["last_name"]
  => "Hartl"
  user["email"]
  => nil

  # Hashes with symbols
  user = { :first_name => "Michael", :last_name => "Hartl" }
  user[:first_name]
  => "Hartl"      </pre>

    </div>

    <div class="slide">
      <h1>Styling with Blueprint CSS</h1>

      <p>
        Download the latest version of Blueprint CSS from <a
        href="http://www.blueprintcss.org/">http://www.blueprintcss.org/</a>
        Unzip or untar it. Then copy the subdirectory "blueprint" into
        your public/stylesheets/ directory.
      </p>

      <pre>
  cd joshuaclayton-blueprint-css-*version number*        
  cp -r blueprint $RAILS_ROOT/public/stylesheets/   
  cd $RAILS_ROOT
  ls public/stylesheets
  blueprint/ 

  # Edit your application layout file to add the screen and print
  styles - and take care of a few IE issues:
  &lt;html&gt;
    &lt;head&gt;
      &lt;title&gt;&lt;%= @title %&gt;&lt;/title&gt;
      &lt;%= csrf_meta_tag %&gt;
      &lt;!--[if lt IE 9]&gt;
      &lt;script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"&gt;&lt;/script&gt;
      &lt;![endif]--&gt;    
      &lt;%= stylesheet_link_tag 'blueprint/screen', :media =&gt; 'screen' %&gt;
      &lt;%= stylesheet_link_tag 'blueprint/print',  :media =&gt; 'print' %&gt;
      &lt;!--[if lt IE 8]&gt;&lt;%= stylesheet_link_tag 'blueprint/ie' %&gt;&lt;![endif]--&gt;
      &lt;%= stylesheet_link_tag 'custom', :media =&gt; 'screen' %&gt;
    &lt;/head&gt; </pre>
    </div>

    <div class="slide">
      <h1>Spicing Up Your Application Layout</h1>

      <p>
        Let's start by looking at Michael's <a
        href="http://railstutorial.org/images/figures/home_page_mockup-full.png">wireframe</a>.
	So, there is going to be a logo at the top - and some standard
        links in the upper left. Let's put those in. 
      </p>
      <p>
        First, let's copy the logo from <a
        href="http://railstutorial.org/images/sample_app/logo.png">http://railstutorial.org/images/sample_app/logo.png</a>
	Place that in your public/images directory. Then use the image
        tag to put it into your page:
      </p>
      <pre>
<%= image_tag("logo.png", :alt => "Sample App", :class => "round") %>        </pre>

      <p>
        And add the links at the top of the page:
      </p>
      <pre>
  &lt;nav class="round"&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;%= link_to "Home", '#' %&gt;&lt;/li&gt;
      &lt;li&gt;&lt;%= link_to "Help", '#' %&gt;&lt;/li&gt;
      &lt;li&gt;&lt;%= link_to "Sign in", '#' %&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/nav&gt;       </pre>
    </div>

    <div class="slide">
      <h1>Routes</h1>

      <p>
        "Normal" web sites serve pages from subdirectories of the
        document root. Rails uses this style of url <-> file matching
        for items under <code>public/</code>. But for the most part
        urls are matched to controllers using routes configured in
        <code>config/routes.rb</code>
      </p>
      
      <pre>
SampleApp::Application.routes.draw do
  match '/contact', :to => 'pages#contact'
  match '/about',   :to => 'pages#about'
  match '/help',    :to => 'pages#help'

  root :to => 'pages#home'
end  </pre>

     <p>
       To reference those routes, don't use the url form ('/about')
       use the helper functions: about_path or about_url.
     </p>

     <pre>
&lt;%= link_to "About", about_path %&gt;  </pre>

    </div>

    <div class="slide">
      <h1>Partials</h1>

      <p>
        OK things are starting to look pretty good. We have everything
        except the footer in place. But have you noticed how
        complicated the layout file is starting to look? That big
        block of stylesheet references is a lot of verbage for
        something so simple. Let's hide that complexity from
        application.html.erb by putting it in its own file. 
      </p>
      
      <pre>
  <%= render "layouts/stylesheets" %>      
  
  # inserts the html from app/views/layouts/_stylesheets.html.erb   </pre>

      <p>
        Let's do the same for our header and footer.
      </p>
    </div>

    <div class="slide">
      <h1>Sign up now!</h1>

      <p>
        Now for that big green button. Sign up is the same thing as
        making a new user. Let's make a new controller for users -
        with an action to create a new user. 
      </p>
      
      <pre>
  rails generate controller Users new      </pre>

      <p>
        That doesn't really do anything yet - but it should
        work. Let's edit the sign up link. But what is the name of the
        new user route that was added?
      </p>

      <pre>
  rake routes
  users_new GET /users/new(.:format) {:controller=>"users", :action=>"new"}
    contact     /contact(.:format)   {:controller=>"pages", :action=>"contact"}
      about     /about(.:format)     {:controller=>"pages", :action=>"about"}
       help     /help(.:format)      {:controller=>"pages", :action=>"help"}
       root     /(.:format)          {:controller=>"pages", :action=>"home"}      </pre>

       <p>
         So we could use users_new_path OR we can add a named route: 
       </p>
      <pre>
  match '/signup', :to => users#new'  </pre>
    </div>

    <div class="slide">
      <h1>User Modeling</h1>

      <p>
        Rails now supports several different methods of storing data -
        but the default is still ActiveRecord - an ORM (object
        relational mapper) that can store data in any one of several
        types of databases. 
      </p>

      <pre>
  rails generate model User name:string email:string  </pre>

      <p>
        Notice models are singular, controllers (and table names) are
        plural. 
      </p>

      <p>
        Look at the migration file. Data definition in bite-sized
        steps - and in ruby so they are database agnositic (as long as
        you don't need a specialized feature of your database). Notice
        <code>t.timestamps</code> - that adds special columns to your
        table: updated_at and created_at. Callbacks will updated those
        automatically when a record is created or updated.
      </p>

      <pre>
  class CreateUsers < ActiveRecord::Migration
    def self.up
      create_table :users do |t|
	t.string :name
	t.string :email

	t.timestamps
      end
    end

    def self.down
      drop_table :users
    end
  end  </pre>

      <pre>
  bundle exec rake db:migrate   </pre>

      <p>
        Let's look at the table using either <a
        href="http://sqlitebrowser.sourceforge.net/">SQLite Database
        Browser</a> or the Firefox <a
        href="https://addons.mozilla.org/en-US/firefox/addon/sqlite-manager/">SQlite
        Manager</a>. Note the id column is added automatically.
      </p>
    </div>

    <div class="slide">
      <h1>The User Class</h1>

      <p>
        So let's look at the Ruby class that represents our User.
      </p>

      <pre>
  class User < ActiveRecord::Base
  end      </pre>

      <p>
        But there's nothing there?! Does it do anything yet? Yes,
        actually it does. Let's break out the rails console and
        see. With only that 1 line, we can create users, store them in
        the database, find them again, edit or get rid of them. Wow!
      </p>

      <p class="incremental">
        Sure would be nice if we could see what attributes our User
        objects have without having to look in the database. 
      </p>

      <p class="incremental">
        We can, using the annotate gem. Do the following:
      </p>

      <pre class="incremental">
  # Edit your Gemfile 
  gem "annotate", :group => :development
  bundle install
  bundle exec annotate --position before
  # Now look at your user.rb model file. Much better!      </pre>
    </div>

    <div class="slide">
      <h1>Validations</h1>

      <p>
        Let's also add some data validations:
      </p>
      <pre>
  class User < ActiveRecord::Base
    attr_accessible :name, :email
    validates :name, :presence => true
  end      </pre>

      <p>
        With that restriction, we get automatic testing of it whenever
        we try to save the record - and a number of convenience
        methods such as <code>a_user.valid?</code> and
        <code>a_user.errors.full_messages</code> 
      </p>

      <pre>
# full set of validations we want
  email_regex = /\A[\w+\-.]+@[a-z\d\-.]+\.[a-z]+\z/i

  validates :name,  :presence => true,
                    :length   => { :maximum => 50 }
  validates :email, :presence => true,
                    :format   => { :with => email_regex },
		    :uniqueness => { :case_sensitive => false } </pre>

<pre>
# add unique index on email
rails generate migration add_email_uniqueness_index

class AddEmailUniquenessIndex < ActiveRecord::Migration
  def self.up
    add_index :users, :email, :unique => true
  end

  def self.down
    remove_index :users, :email
  end
end   </pre>
    </div>

    <div class="slide">
      <h1>User's home page</h1>

      <p>
        Let's make a page to show what we know about a user. The rails
        default for such a page is called show:
      </p>

      <pre>
class UsersController < ApplicationController
  def show
    @user = User.find(params[:id])
  end
...
end    </pre>

      <p>
        And we should create the file
        app/views/users/show.html.erb. Hmmm but it still doesn't work
        because there is no route. Let's add the following - and then
        use <code>rake routes</code> to see what that did.
      </p>

      <pre>
  resources :users  </pre>
    </div>

    <div class="slide">
      <h1>Password Fields</h1>

      <p>
        So we created some users - but without passwords how do I know
        you are who you say you are? 
      </p>

      <p>
        A password and password confirmation field are pretty standard
        for most signup forms on the web. But we don't want to store
        the password confirmation - in fact we don't really want to
        store the password, at least not the way you typed it in. For
        security, it should be encrypted. So what we need are some
        "virtual attributes". (From the point of view of the User
        class, they are real attributes but from ActiveRecord's
        perspective, they aren't.)
      </p>

      <pre>
attr_accessor :password

# Automatically create the virtual attribute 'password_confirmation'.
validates :password, :presence     => true,
                     :confirmation => true,
                     :length       => { :within => 6..40 }      </pre>
    </div>

    <div class="slide">
      <h1>Password Migration</h1>

      <p>
        OK but where are we going to store the password? In a field
        called encrypted_password. (We'll show you how the password
        you type in becomes an encrypted password in a minute.)
      </p>

      <pre>
rails generate migration add_password_to_users encrypted_password:string      </pre>

      <p>
        Look at the generated migration file. Impressive, yes? That is
        rail's "Convention over Configuration" at work.
      </p>

      <pre>
class AddPasswordToUsers < ActiveRecord::Migration
  def self.up
    add_column :users, :encrypted_password, :string
  end

  def self.down
    remove_column :users, :encrypted_password
  end
end  </pre>
    </div>

    <div class="slide">
      <h1>Saving the Encrypted Password</h1>

      <p>
        So we have validated our password and password confirmation
        fields. But how do we store the password into the
        encrypted_password field? We'll use an ActiveRecord callback
        to automate this process:
      </p>

      <pre>
class User < ActiveRecord::Base
...
  before_save :encrypt_password

  private

    def encrypt_password
      self.encrypted_password = encrypt(password)
    end

    def encrypt(string)
      string # Only a temporary implementation!
    end
end      </pre>
  
      <p>
        Note the keyword "private" and assignment using self.encrypted_password.
      </p>
    </div>

    <div class="slide">
      <h1>Checking the Password</h1>

      <p>
        So ignore for now that we are not really encrypting
        passwords. How will we check the password you supply on a
        login form? 
      </p>

      <pre>
  # Encrypt the password you just submitted and compare it to the encrypted one
  def has_password?(submitted_password)
    encrypted_password == encrypt(submitted_password)
  end      </pre>
    </div>

    <div class="slide">
      <h1>Password Encryption</h1>

      <p>
        The standard way of storing passwords is to use a one-way
        hash. One way means that you can't deduce the password from
        knowing the encrypted password. However with enough time, you
        can compute likely hashes and compare them until you find a
        match. To make that harder, it is recommended to use a salt -
        an extra piece of data that gets encrypted with the password.
      </p>

      <p>
        So let's start by creating a column for the salt:
      </p>

      <pre>
  rails generate migration add_salt_to_users salt:string      </pre>
      
      <p>
        Now for the full encryption functions:
      </p>

      <pre>
    def encrypt_password
      self.salt = make_salt unless has_password?(password)
      self.encrypted_password = encrypt(password)
    end

    def encrypt(string)
      secure_hash("#{salt}--#{string}")
    end

    def make_salt
      secure_hash("#{Time.now.utc}--#{password}")
    end

    def secure_hash(string)
      Digest::SHA2.hexdigest(string)
    end      </pre>
    </div>

    <div class="slide">
      <h1>User Authentication</h1>

      <p>
        So to authenticate a user, we need to look up the user record,
        grab the salt, encrypt the supplied password, and compare it
        to the one the user just typed in. Not terribly complex - but
        wouldn't it be nice to have that available as a single action
        so you don't have to repeat those steps everywhere you want to
        check on a user? Let's make a method to do that.
      </p>

      <p>
        The methods we have created up to this point have been
        instance methods - they act on a particular user. But we don't
        have a specific user yet - that's what we are trying to figure
        out. So we'll need a class method.
      <p>

      <pre>
class User < ActiveRecord::Base

  def self.authenticate(email , submitted_password)
    user = find_by_email(email)
    return nil  if user.nil?  # no user with that email
    return user if user.has_password?(submitted_password)
  end
end

# To use this:
@user = User.authenticate(email, password)      </pre>
    </div>

    <div class="slide">
      <h1>Gravatars</h1>

      <p>
        Let's spruce up our user display page a bit. Have you seen
        blog comments where the comment had someone's picture next to
        it? Fancy, huh? But actually pretty simple because there is a
        web service you can use to add those images to your pages: <a
        href="http://en.gravatar.com/">http://en.gravatar.com/</a> 
      </p>

      <p>
        A quick look at the <a
        href="http://en.gravatar.com/site/implement/hash/">Gravatar
        instructions</a> show it isn't very complicated to use the
        server. But in the Rails ecosystem it is even easier: there's
        a gem for that!
      </p>

      <pre>
  # Edit your gem file:
  gem 'gravatar_image_tag'

  bundle install

  # in app/views/users/show.html.erb
  <%= gravatar_image_tag 'example@railstutorial.org' %>      </pre>

      <p>
        Also add the user sidebar (section 7.3.3) and augement the stylesheet.
      </p>
    </div>

    <div class="slide">
      <h1>Signup Form</h1>

      <p>
        Standard web form behavior is to return error messages next to
        the field that has the bad data in it - without losing any of
        the other data you have entered into the form. Doing that by
        hand is tedious. Rails takes the drudgery out of that with
        <code>form_for</code> and a handful of form helpers like
        <code>text_field</code>.
      </p>

      <pre>
# app/views/users/new.html.erb
&lt;h1&gt;Sign up&lt;/h1&gt;

&lt;%= form_for(@user) do |f| %&gt;
  &lt;div class="field"&gt;
    &lt;%= f.label :name %&gt;&lt;br /&gt;
    &lt;%= f.text_field :name %&gt;
  &lt;/div&gt;
  &lt;div class="field"&gt;
    &lt;%= f.label :email %&gt;&lt;br /&gt;
    &lt;%= f.text_field :email %&gt;
  &lt;/div&gt;
  &lt;div class="field"&gt;
    &lt;%= f.label :password %&gt;&lt;br /&gt;
    &lt;%= f.password_field :password %&gt;
  &lt;/div&gt;
  &lt;div class="field"&gt;
    &lt;%= f.label :password_confirmation, "Confirmation" %&gt;&lt;br /&gt;
    &lt;%= f.password_field :password_confirmation %&gt;
  &lt;/div&gt;
  &lt;div class="actions"&gt;
    &lt;%= f.submit "Sign up" %&gt;
  &lt;/div&gt;
&lt;% end %&gt;      </pre>

      <pre>
# app/controllers/users_controller.rb
  def new
    @user = User.new  # need this for form_for to act on
    @title = "Sign up"
  end  </pre>

    </div>

    <div class="slide">
      <h1>Signup Form 2</h1>

      <p>
        Now let's look at the html generated by form_for and friends:
      </p>
      
      <pre>
# Form fields. Note the generated name
&lt;input id="user_name" name="user[name]" - - - /&gt;

# And the form definition itself:
&lt;form action="/users" class="new_user" id="new_user" method="post"&gt;
&lt;div style="margin:0;padding:0;display:inline"&gt;
&lt;input name="authenticity_token" type="hidden"
       value="rB82sI7Qw5J9J1UMILG/VQL411vH5putR+JwlxLScMQ=" /&gt;
&lt;/div&gt;      </pre>

      <p>
        So when we submit the form, where will it end up? Let's check
        our routes:
      </p>

      <pre>
$ rake routes
    users GET    /users(.:format)          {:action=>"index",  :controller=>"users"}
          POST   /users(.:format)          {:action=>"create", :controller=>"users"}
 new_user GET    /users/new(.:format)      {:action=>"new",    :controller=>"users"}
edit_user GET    /users/:id/edit(.:format) {:action=>"edit",   :controller=>"users"}
     user GET    /users/:id(.:format)      {:action=>"show",   :controller=>"users"}
          PUT    /users/:id(.:format)      {:action=>"update", :controller=>"users"}
          DELETE /users/:id(.:format)      {:action=>"destroy", :controller=>"users"}      </pre>
    </div>

    <div class="slide">
      <h1>Create a User</h1>

      <pre>
class UsersController < ApplicationController
  def create
    @user = User.new(params[:user])
    if @user.save
      redirect_to @user
    else
      @title = "Sign up"
      render 'new'
    end
  end
end  </pre>

    </div>

    <div class="slide">
      <h1>Error Handling </h1>

      <p>
        Recall that ActiveRecord gives you an array of error messages
        - everything that is wrong with the user you tried to create:
	<code>a_user.errors.full_messages</code> So how can we show
        those to the user? 
      </p>

      <pre>
# make a partial app/views/shared/_error_messages.html.erb
&lt;% if @user.errors.any? %&gt;
  &lt;div id="error_explanation"&gt;
    &lt;h2&gt;&lt;%= pluralize(@user.errors.count, "error") %&gt; 
        prohibited this user from being saved:&lt;/h2&gt;
    &lt;p&gt;There were problems with the following fields:&lt;/p&gt;
    &lt;ul&gt;
    &lt;% @user.errors.full_messages.each do |msg| %&gt;
      &lt;li&gt;&lt;%= msg %&gt;&lt;/li&gt;
    &lt;% end %&gt;
    &lt;/ul&gt;
  &lt;/div&gt;
&lt;% end %&gt;      </pre>
      
      <p>
        Ruby goodness: .any?, .each do |msg| end. Rails goodness: pluralize
      </p>
    </div>

    <div class="slide">
      <h1>Flash Notices</h1>

      <p>
        When user creation succeeds, the user gets redirected to their
        user page. But perhaps we would like to set a temporary
        message on that first page view. For example: "Welcome! You
        can now start posting!" Rails provides a way to add a
        temporary message for the very next page view - called the flash.
      </p>

      <pre>
# To create them:
  # In app/controllers/users_controller.rb
  flash[:success] = "Welcome to the Sample App!"
      </pre>

      <pre>
# To display them
  # In app/views/layouts/application.html.erb
  &lt;% flash.each do |key, value| %&gt;
    &lt;div class="flash &lt;%= key %&gt;"&gt;&lt;%= value %&gt;&lt;/div&gt;
  &lt;% end %&gt;      </pre>
    </div>

    <div class="slide">
      <h1>User Sessions</h1>

      <p>
        You can look at being signed in or not as an attribute of the
        user. But Rails prefers to think of signing in as "creating a
        new session" and signing out as "destroying a session". So the
        usual way to implement user sign ins in Rails is to create a
        Session controller.
      </p>

      <pre>
  rails generate controller Sessions new      </pre>

      <p>
        We will also need actions for create and destroy - but they
        won't need views, so we'll just add them by hand later. We
        will need some routes - and will probably want them to have
        pretty names.
      </p>

      <pre>
SampleApp::Application.routes.draw do
  resources :users
  resources :sessions, :only => [:new, :create, :destroy]

  match '/signup',  :to => 'users#new'
  match '/signin',  :to => 'sessions#new'
  match '/signout', :to => 'sessions#destroy'
...      </pre>

    </div>

    <div class="slide">
      <h1>Sign In Form</h1>

      <p>
        So to sign in, we'll need a form that is similar to our signup
        form - except we'll only need email and password. The other
        main difference is that we don't have a database model for the
        session (it's data is stored in a session cookie on your
        browser). So we'll need to use form_for a little differently:
      </p>

      <pre>
  # instead of 
  form_for(@user)

  # we need to tell form_for the name of the resource and a target url
  form_for(:session, :url => sessions_path)          </pre>

      <pre>
# app/views/sessions/new.html.erb
&lt;h1&gt;Sign in&lt;/h1&gt;

&lt;%= form_for(:session, :url =&gt; sessions_path) do |f| %&gt;
  &lt;div class="field"&gt;
    &lt;%= f.label :email %&gt;&lt;br /&gt;
    &lt;%= f.text_field :email %&gt;
  &lt;/div&gt;
  &lt;div class="field"&gt;
    &lt;%= f.label :password %&gt;&lt;br /&gt;
    &lt;%= f.password_field :password %&gt;
  &lt;/div&gt;
  &lt;div class="actions"&gt;
    &lt;%= f.submit "Sign in" %&gt;
  &lt;/div&gt;
&lt;% end %&gt;

&lt;p&gt;New user? &lt;%= link_to "Sign up now!", signup_path %&gt;&lt;/p&gt;      </pre>

    </div>

    <div class="slide">
      <h1>Sign In Form 2</h1>

      <p class="incremental">
        So what is the usual logic for form submission?
      </p>

      <p class="incremental">
        We saw how to implement that with form_for and an ActiveRecord
        model (validations, error reporting, etc.). So how do we do
        that with our session form? 
      </p>

      <p class="incremental">
        We use our User.authenticate action
      </p>
      
      <pre class="incremental">
  def create
    user = User.authenticate(params[:session][:email],
                             params[:session][:password])
    if user.nil?
      # Create error messages and rerender new
      flash.now[:error] = "Invalid email/password combination."
      @title = "Sign in"
      render 'new'
    else
      # set session cookie and redirect user to his own page
    end
 end      </pre>
    </div>

    <div class="slide">
      <h1>Session Cookies</h1>

      <p>
        The most common way of keeping track of user sessions is to
        use browser cookies. Rails has machinery for creating
        encrypted cookies and allowing you to easily store data in and
        retrieve data from the cookie. We don't want everyone to be
        able to read that user_id so we are going to encrypt it. We
        will reuse the salt we created to encrypt each user's
        password to encrypt their user id before storing it in a
        cookie named "remember_token".
      </p>

      <pre>
  def sign_in(user)
    cookies.permanent.signed[:remember_token] = [user.id, user.salt]
    self.current_user = user
  end      </pre>

      <p>
        For more details on security threats and how to use Rails to
        counter them, see the <a
        href="http://guides.rubyonrails.org/security.html">Rails
        Security Guide</a>.
      </p>
    </div>

    <div class="slide">
      <h1>Session Cookies 2</h1>

      <p>
        But where does the code above go? We will need to know if you
        are signed in or not in our controllers and in our
        views. Views already load all helper methods - and we can
        easily load the SessionHelper module in our application
        controller. So let's put our sign_in code and its auxillary
        functions in to the SessionsHelper module.
      </p>

      <pre>
module SessionsHelper
  def sign_in(user)
    cookies.permanent.signed[:remember_token] = [user.id, user.salt]
    self.current_user = user
  end

  # and a a nice method for checking if the person viewing this page is signed in
  def signed_in?
    !current_user.nil?
  end
end 

class ApplicationController &lt; ActionController::Base
  protect_from_forgery
  include SessionsHelper
end      </pre>

    </div>

    <div class="slide">
      <h1>Setting the Current User</h1>

      <p>
        In the previous step, we created a current_user attribute in
        the session. Or did we? We haven't created a setter method for
        current_user. There isn't an attr_write nor an current_user=
        method. If you try to sign in right now, you will get a stack trace:
      </p>

      <pre class="incremental">
NoMethodError in SessionsController#create

undefined method `current_user=' for #&lt;SessionsController:0xb1d8d40&gt;

app/helpers/sessions_helper.rb:5:in `sign_in'
app/controllers/sessions_controller.rb:16:in `create' </pre>


      <p class="incremental">
	We better create methods for setting and retrieving the
        current user from the session. NB @current_user is an instance
        variable of the current session.
      </p>

      <pre class="incremental">
  def current_user=(user)
    @current_user = user
  end </pre>

    </div>

    <div class="slide">
      <h1>Using the Current User Variable</h1>

      <p>
        You might think we could just create a getter that returns
        @current_user. However, since that is an instance variable,
        you would get a different instance for every page request. Not
        very helpful if you are trying to preserve state across
        multiple page requests.
      </p>

      <pre>
  def current_user
    @current_user ||= user_from_remember_token
  end

  private

    def user_from_remember_token
      User.authenticate_with_salt(*remember_token)
    end

    def remember_token
      cookies.signed[:remember_token] || [nil, nil]
    end      </pre>

      <p>
	Note a couple of Ruby tricks: ||= and the splat operator *array
      </p>
    </div>

    <div class="slide">
      <h1>Authenticating Users with ID and Salt</h1>

      <pre>
class User < ActiveRecord::Base
...
  def self.authenticate(email, submitted_password)
    user = find_by_email(email)
    return nil  if user.nil?
    return user if user.has_password?(submitted_password)
  end

  def self.authenticate_with_salt(id, cookie_salt)
    user = find_by_id(id)
    (user && user.salt == cookie_salt) ? user : nil
  end
end      </pre>

      <p>
	The two methods above have the exact same logic - but the
	second one is written using the ternary operator. If you have
	seen it before, feel free to use it. Otherwise, it is also OK
	to use the longer, more explicit form of the first method.
      </p>
    </div>

    <div class="slide">
      <h1>Signing Out</h1>

      <p>
	So signing out is the same thing as "destroying" the
	session. Essentially we need to clear out the remember_token
	cookie and the @current_user variable. And then take the user ??? 
      </p>
      
      <pre>
class SessionsController &lt; ApplicationController

 def destroy
    sign_out
    redirect_to root_path
  end
end      </pre>

      <pre>
module SessionsHelper

  def sign_out
    cookies.delete(:remember_token)
    self.current_user = nil
  end
end      </pre>
      
    </div>

    <div class="slide">
      <h1>Signing In When Signing Up</h1>

      <p>
	Now that we can sign people in, we should probably do that
	automatically when someone signs up. So let's modify our
	User#create action to do that.
      </p>

      <pre>
class UsersController < ApplicationController

  def create
    @user = User.new(params[:user])
    if @user.save
      sign_in @user
      flash[:success] = "Welcome to the Sample App!"
      redirect_to @user
    else
      @title = "Sign up"
      render 'new'
    end
  end
end      </pre>

    </div>

    <div class="slide">
      <h1>Tweaking Our Layout</h1>

      <p>
	It is customary to have the sign in link change to a sign out
	link once a user signs in. We had better provide a sign out
	link to our users - especially as we use permanent cookies for
	this app. We will probably also want users to be able to get
	back to their own page at any time while they are signed in.
      </p>

      <pre>
&lt;header&gt;
  &lt;%= image_tag("logo.png", :alt => "Sample App", :class => "round") %&gt;
  &lt;nav class="round"&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;%= link_to "Home", root_path %&gt;&lt;/li&gt;
      &lt;% if signed_in? %&gt;
          &lt;li&gt;&lt;%= link_to "Profile", current_user %&gt;&lt;/li&gt;
      &lt;% end %&gt;
      &lt;li&gt;&lt;%= link_to "Help", help_path %&gt;&lt;/li&gt;
      &lt;% if signed_in? %&gt;
          &lt;li&gt;&lt;%= link_to "Sign out", signout_path, :method =&gt; :delete %&gt;&lt;/li&gt;
      &lt;% else %&gt;
          &lt;li&gt;&lt;%= link_to "Sign in", signin_path %&gt;&lt;/li&gt;
      &lt;% end %&gt;
    &lt;/ul&gt;
  &lt;/nav&gt;
&lt;/header&gt;
      </pre>
    </div>

    <div class="slide">
      <h1>Editing User Information</h1>

      <p>
	But what if my email address changes? Let's add an edit action.
      </p>

      <pre>
  def edit
    @user = User.find(params[:id])
    @title = "Edit user"
  end      </pre>

      <p>
	The edit form needs to look a lot like the sign up form. Can't
	we just reuse it? Let's refactor it so we can. First, remove
	the form contents from new.html.erb and put them in a file
	called _form.html.erb. And reinclude them as below:
      </p>

      <pre>
  <%= render :partial => 'form', :locals => { :f => f } %>      </pre>


      <p>
	Then you can copy new.html.erb into edit.html.erb and modify
	as need be.
      </p>

      <p>
	Now, let's make it possible to get to the edit page by adding
	a "Settings" link when you are signed in:
      </p>

      <pre>
      &lt;% if signed_in? %&gt;
          &lt;li&gt;&lt;%= link_to "Profile", current_user %&gt;&lt;/li&gt;
          &lt;li&gt;&lt;%= link_to "Settings", edit_user_path(current_user) %&gt;&lt;/li&gt;
      &lt;% end %&gt;      </pre>

    </div>

    <div class="slide">
      <h1>Update User Info</h1>

      <p>
	By now you are kind of getting the hang of page flow. We'll
	need an action to receive the form information, validate it,
	and return errors or redirect back to the profile page. By
	convention Rails calls this action "update".
      </p>

      <pre>
  def update
    @user = User.find(params[:id])
    if @user.update_attributes(params[:user])
      flash[:success] = "Profile updated."
      redirect_to @user
    else
      @title = "Edit user"
      render 'edit'
    end
  end      </pre>
    </div>

    <div class="slide">
      <h1>Protecting pages</h1>

      <p>
	Pretty nifty, huh? The update_attributes function is the bee's
	knees. But at the moment, any and everyone can edit your
	profile information. Hmmm perhaps we should restrict that so
	that you can only edit your own profile.
      </p>

      <pre class="incremental">
class UsersController < ApplicationController
  before_filter :authenticate, :only => [:edit, :update]
  ...
  private

    def authenticate
      deny_access unless signed_in?
    end
end      </pre>

      <pre class="incremental">
module SessionsHelper
  ...
  def deny_access
    redirect_to signin_path, :notice => "Please sign in to access this page."
  end
end      </pre>

    </div>

    <div class="slide">
      <h1>Protecting pages 2</h1>

      <p>
	The previous code made is so only signed in users can edit
	profiles - but it still didn't mean you couldn't edit someone
	else's profile. Let's add another filter for that:
      </p>

      <pre class="incremental">
class UsersController < ApplicationController
  before_filter :authenticate, :only => [:edit, :update]
  before_filter :correct_user, :only => [:edit, :update]
  ....
  private

    def authenticate
      deny_access unless signed_in?
    end

    def correct_user
      @user = User.find(params[:id])
      redirect_to(root_path) unless current_user?(@user)
    end
end      </pre>

      <pre class="incremental">
module SessionsHelper
  ...

  def current_user?(user)
    user == current_user
  end

  def deny_access
    redirect_to signin_path, :notice => "Please sign in to access this page."
  end
end      </pre>

      <p class="incremental">
	And now that we are only allowing the current user to edit, we
	don't need to look up the user from params[:id], we can just
	use the current_user. So the edit action changes as follows:
      </p>

      <pre class="incremental">
def edit
  @user = User.find(params[:id])
  @title = "Edit user"
end

def edit
  # correct_user filter now sets @user 
  @title = "Edit user"
end
      </pre>

    </div>

    <div class="slide">
      <h1>Better Page Flow</h1>

      <p>
        OK our edit function is now secure. But it is kind of
        annoying. If the user gets redirected to the sign in page, she
        ends up on her profile display page - even if she had been in
        the middle of trying to edit the profile. That isn't the
        behavior you expect - you want to go right back to editing,
        right?
     </p> 

     <p>
       Remember that phrase about "HTTP is a stateless protocol"? So
       if we want to go "back where we started" then we'll need to
       store that information explicitly. Fortunately, Rails has a
       session cookie just for stuff like this.
     </p>

     <pre>
module SessionsHelper
  ...
  def deny_access
    store_location
    redirect_to signin_path, :notice => "Please sign in to access this
  page."
  end

  def redirect_back_or(default)
    redirect_to(session[:return_to] || default)
    clear_return_to
  end

  private
    ...
    def store_location
      session[:return_to] = request.fullpath
    end

    def clear_return_to
      session[:return_to] = nil
    end
end      </pre>

     <pre>
  # and change the last line of SessionsController#create from
  # redirect_to user
  redirect_back_or user
     </pre>

    </div>

    <div class="slide">
      <h1>Making It Social</h1>

      <p>
        So far we have built the user infrastructure that 90% of web
        sites need these days. But our "social media" Twitter clone
        is, so far, pretty anti-social. There isn't any way to see
        other users of the site. Let's fix that. Let's create a page
        listing all the users. In Rails/REST convention, that page is
        called the index page and should be at the "/users" url. We
        only want other signed in users to see that list, so let's add
        index to the list of restricted pages. 
      </p>

      <pre>
class UsersController < ApplicationController
  before_filter :authenticate, :only => [:index, :edit, :update]
  ...
  def index
    @title = "All users"
    @users = User.all
  end      </pre>

      <pre>
# app/views/users/index.html.erb
&lt;h1&gt;All users&lt;/h1&gt;

&lt;ul class="users"&gt;
  &lt;% @users.each do |user| %&gt;
    &lt;li&gt;
      &lt;%= gravatar_for user, :size =&gt; 30 %&gt;
      &lt;%= link_to user.name, user %&gt;
    &lt;/li&gt;
  &lt;% end %&gt;
&lt;/ul&gt;      </pre>

      <pre>
  # and add a link to Users in the navigation - if you are signed in
      &lt;li&gt;&lt;%= link_to "Users", users_path %&gt;&lt;/li&lt;
</pre>

      <p>
        Section 10.3.3 shows you an extremely convenient Rails
        extension to easily split the user list (or any other list)
        onto multiple pages using the will-paginate gem. We are going
        to skip this, but take a look at <a
        href="http://ruby.railstutorial.org/chapters/updating-showing-and-deleting-users#sec:pagination">the
        book</a> when you have time.
      </p>
      
    </div>

  </body>
</html>
