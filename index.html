<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-US">
  <head>
    <meta name="generator" content="HTML Tidy for Linux/x86 (vers 1st November 2003), see www.w3.org" />
    <title>Rails Tutorial Using Rails 3.0.10</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="copyright" content="Copyright &#169; 2011 The Rubyists http://therubyists.org" />
    <meta name="duration" content="20" />
    <link rel="stylesheet" href="http://www.w3.org/Talks/Tools/Slidy2/styles/slidy.css" type="text/css" />
    <script src="http://www.w3.org/Talks/Tools/Slidy2/scripts/slidy.js" charset="utf-8" type="text/javascript"></script>
  </head>
  <body>
    <div class="slide">
      <h1>Welcome</h1>

      <p>
        Welcome to the LA Ruby Study Group Rails Tutorial Workshop.
      </p>

      <p>
        We are going to work through the Rails Tutorial book. You will
        have already worked through the install steps last
        weekend. Tonight we will be starting right in with Chapter 3 -
        Mostly Static Pages.
      </p>
      
      <p>
        We will be skipping the testing portions of the book. In the
        long run, testing saves time you would spend debugging or
        doing <i>ad hoc</i> testing - but in the short run it takes
        time.
      </p>

    </div>

    <div class="slide">
      <h1>Our Sample App</h1>

      <pre>
  cd _wherever_you_want_to_work_
  rails new sample_app

  app/   - this is where your application lives
     controllers/
     helpers/
     models/
     views/
  config/  - application configuration, e.g. database.yml
  db/migrations/ - database-agnostic schema definition
  log/     - log files. Look here for debugging information
  public/  - images, stylesheets, javascript
  Gemfile  - what gems should we load for this application? 
  .gitignore -  Lists of files we don't want version controlled      </pre>
    </div>

    <div class="slide">
      <h1>Start Your Server</h1>

      <pre>
  cd sample_app
  bundle install
  rails server	
  => Booting WEBrick
  => Rails 3.0.9 application starting on http://0.0.0.0:3000
  => Call with -d to detach
  => Ctrl-C to shutdown server      </pre>

      <p>
        In your web browser, got to <a href="http://localhost:3000">http://localhost:3000</a>
      </p>
    </div>

    <div class="slide">
      <h1>Using Git</h1>

      <p>
        Version control is a good development practice. It is also the
        tool we are going to use to transfer the code you have on your
        local machine to Heroku - a web host where the rest of the
        world can see your handiwork. 
      </p>

      <pre>
  Initial (one time) setup: 
  git config --global user.name "Your Name"
  git config --global user.name "Your Name"

  git init
  # Possibly edit the .gitignore file
  git add . 
  git commit -m "Bare rails project"      </pre>
    </div>

    <div class="slide">
      <h1>Deploy</h1>

      <p>
        Everyone signed up for a free Heroku account, right? <a
        href="https://api.heroku.com/signup">https://api.heroku.com/signup</a> 
      </p>

      <pre>
  gem list heroku

  heroku keys:add
  heroku create
  git push heroku master

  heroku open      </pre>
      <p>
        Don't worry about the fact the "About your application's
        environment" link doesn't work on Heroku. That's normal. We'll
        be replacing that page with something more interesting soon.
      </p>
    </div>

    <div class="slide">
      <h1>Static Pages</h1>

      <p>
        Any page or file placed within the public/ directory will be
        served directly from that location without passing through the
        rails routing system. For example, let's create a file
        public/hello.html
     </p>

     <p>
       That's nice. But it has all the disadvantages of a static web
       page. For example, it must contain all of the styling
       information for the page. And if that changes, it needs to be
       changed on every page. That violates one of Rails' guiding
       principles: <b>Don't Repeat Yourself</b>
     </p>

      <p>
        Rails can offer you a better option - using the Rails
        templating system to apply a common layout. 
      </p>
    </div>

    <div class="slide">
      <h1>Not Really Static Pages</h1>

      <pre>
  rails generate controller Pages home contact      
      create  app/controllers/pages_controller.rb
       route  get "pages/contact"
       route  get "pages/home"
      invoke  erb
      create    app/views/pages
      create    app/views/pages/home.html.erb
      create    app/views/pages/contact.html.erb      </pre>

      <p>
        This will have generated a controller named Pages and added 2
        actions to it: home and contact. It has also added routes and pages.
	Let's look at them.
      </p>
    </div>

    <div class="slide">
      <h1>Common Layout</h1>

      <p>
        Let's take advantage of the site layout file. Let's add a
        title to each page.
      </p>

      <pre>
  class PagesController < ApplicationController
    def home
      @title = "Home"
    end
  end      </pre>

      <p>
        Views: html + ruby. The text between &lt;% and %&gt; is
        evaluated as ruby. If there is an equal sign, the result of
        the ruby is placed in the html:  &lt;%= 2+2 %&gt; yields
        4. The value of instance variables can be placed in a view.
      </p>

      <pre>
  &lt;title&gt;&lt;%= @title %&gt;&lt;/title&gt;     </pre>
    </div>

    <div class="slide">
      <h1>A Sliver of Ruby</h1>

      <pre>
  module ApplicationHelper

    # Return a title on a per-page basis.
    def title
      base_title = "Ruby on Rails Tutorial Sample App"
      if @title.nil?
	base_title
      else
	"#{base_title} | #{@title}"
      end
    end
  end  </pre>

      <ul>
        <li>How to define methods, variables, and comments</li>
        <li>if-else-end syntax</li>
	<li>foo.nil?  (Rails also gives you foo.blank?)</li>
	<li>String interpolation: "#{variable} plus litteral text"
	<li>Application Helper methods are available in all views on
        your site</li>
      </ul>
    </div>

    <div class="slide">
      <h1>A Bit More Ruby</h1>

      <pre>
  # Array's 
  a = [23, 43, "foo", "zombies"]
  puts a[0] 
  => 23
  a.length 
  => 4

  # Hashes
  user = { "first_name" => "Michael", "last_name" => "Hartl" }
  user["last_name"]
  => "Hartl"
  user["email"]
  => nil

  # Hashes with symbols
  user = { :first_name => "Michael", :last_name => "Hartl" }
  user[:first_name]
  => "Hartl"      </pre>

    </div>

    <div class="slide">
      <h1>Styling with Blueprint CSS</h1>

      <p>
        Download the latest version of Blueprint CSS from <a
        href="http://www.blueprintcss.org/">http://www.blueprintcss.org/</a>
        Unzip or untar it. Then copy the subdirectory "blueprint" into
        your public/stylesheets/ directory.
      </p>

      <pre>
  cd joshuaclayton-blueprint-css-*version number*        
  cp -r blueprint $RAILS_ROOT/public/stylesheets/   
  cd $RAILS_ROOT
  ls public/stylesheets
  blueprint/ 

  # Edit your application layout file to add the screen and print
  styles - and take care of a few IE issues:
  &lt;html&gt;
    &lt;head&gt;
      &lt;title&gt;&lt;%= @title %&gt;&lt;/title&gt;
      &lt;%= csrf_meta_tag %&gt;
      &lt;!--[if lt IE 9]&gt;
      &lt;script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"&gt;&lt;/script&gt;
      &lt;![endif]--&gt;    
      &lt;%= stylesheet_link_tag 'blueprint/screen', :media =&gt; 'screen' %&gt;
      &lt;%= stylesheet_link_tag 'blueprint/print',  :media =&gt; 'print' %&gt;
      &lt;!--[if lt IE 8]&gt;&lt;%= stylesheet_link_tag 'blueprint/ie' %&gt;&lt;![endif]--&gt;
      &lt;%= stylesheet_link_tag 'custom', :media =&gt; 'screen' %&gt;
    &lt;/head&gt; </pre>
    </div>

    <div class="slide">
      <h1>Spicing Up Your Application Layout</h1>

      <p>
        Let's start by looking at Michael's <a
        href="http://railstutorial.org/images/figures/home_page_mockup-full.png">wireframe</a>.
	So, there is going to be a logo at the top - and some standard
        links in the upper left. Let's put those in. 
      </p>
      <p>
        First, let's copy the logo from <a
        href="http://railstutorial.org/images/sample_app/logo.png">http://railstutorial.org/images/sample_app/logo.png</a>
	Place that in your public/images directory. Then use the image
        tag to put it into your page:
      </p>
      <pre>
<%= image_tag("logo.png", :alt => "Sample App", :class => "round") %>        </pre>

      <p>
        And add the links at the top of the page:
      </p>
      <pre>
  &lt;nav class="round"&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;%= link_to "Home", '#' %&gt;&lt;/li&gt;
      &lt;li&gt;&lt;%= link_to "Help", '#' %&gt;&lt;/li&gt;
      &lt;li&gt;&lt;%= link_to "Sign in", '#' %&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/nav&gt;       </pre>
    </div>

    <div class="slide">
      <h1>Routes</h1>

      <p>
        "Normal" web sites serve pages from subdirectories of the
        document root. Rails uses this style of url <-> file matching
        for items under <code>public/</code>. But for the most part
        urls are matched to controllers using routes configured in
        <code>config/routes.rb</code>
      </p>
      
      <pre>
SampleApp::Application.routes.draw do
  match '/contact', :to => 'pages#contact'
  match '/about',   :to => 'pages#about'
  match '/help',    :to => 'pages#help'

  root :to => 'pages#home'
end  </pre>

     <p>
       To reference those routes, don't use the url form ('/about')
       use the helper functions: about_path or about_url.
     </p>

     <pre>
&lt;%= link_to "About", about_path %&gt;  </pre>

    </div>

    <div class="slide">
      <h1>Partials</h1>

      <p>
        OK things are starting to look pretty good. We have everything
        except the footer in place. But have you noticed how
        complicated the layout file is starting to look? That big
        block of stylesheet references is a lot of verbage for
        something so simple. Let's hide that complexity from
        application.html.erb by putting it in its own file. 
      </p>
      
      <pre>
  <%= render "layouts/stylesheets" %>      
  
  # inserts the html from app/views/layouts/_stylesheets.html.erb   </pre>

      <p>
        Let's do the same for our header and footer.
      </p>
    </div>

    <div class="slide">
      <h1>Sign up now!</h1>

      <p>
        Now for that big green button. Sign up is the same thing as
        making a new user. Let's make a new controller for users -
        with an action to create a new user. 
      </p>
      
      <pre>
  rails generate controller Users new      </pre>

      <p>
        That doesn't really do anything yet - but it should
        work. Let's edit the sign up link. But what is the name of the
        new user route that was added?
      </p>

      <pre>
  rake routes
  users_new GET /users/new(.:format) {:controller=>"users", :action=>"new"}
    contact     /contact(.:format)   {:controller=>"pages", :action=>"contact"}
      about     /about(.:format)     {:controller=>"pages", :action=>"about"}
       help     /help(.:format)      {:controller=>"pages", :action=>"help"}
       root     /(.:format)          {:controller=>"pages", :action=>"home"}      </pre>

       <p>
         So we could use users_new_path OR we can add a named route: 
       </p>
      <pre>
  match '/signup', :to => users#new'  </pre>
    </div>

    <div class="slide">
      <h1>User Modeling</h1>

      <p>
        Rails now supports several different methods of storing data -
        but the default is still ActiveRecord - an ORM (object
        relational mapper) that can store data in any one of several
        types of databases. 
      </p>

      <pre>
  rails generate model User name:string email:string  </pre>

      <p>
        Notice models are singular, controllers (and table names) are
        plural. 
      </p>

      <p>
        Look at the migration file. Data definition in bite-sized
        steps - and in ruby so they are database agnositic (as long as
        you don't need a specialized feature of your database). Notice
        <code>t.timestamps</code> - that adds special columns to your
        table: updated_at and created_at. Callbacks will updated those
        automatically when a record is created or updated.
      </p>

      <pre>
  class CreateUsers < ActiveRecord::Migration
    def self.up
      create_table :users do |t|
	t.string :name
	t.string :email

	t.timestamps
      end
    end

    def self.down
      drop_table :users
    end
  end  </pre>

      <pre>
  bundle exec rake db:migrate   </pre>

      <p>
        Let's look at the table using either <a
        href="http://sqlitebrowser.sourceforge.net/">SQLite Database
        Browser</a> or the Firefox <a
        href="https://addons.mozilla.org/en-US/firefox/addon/sqlite-manager/">SQlite
        Manager</a>. Note the id column is added automatically.
      </p>
    </div>

    <div class="slide">
      <h1>The User Class</h1>

      <p>
        So let's look at the Ruby class that represents our User.
      </p>

      <pre>
  class User < ActiveRecord::Base
  end      </pre>

      <p>
        But there's nothing there?! Does it do anything yet? Yes,
        actually it does. Let's break out the rails console and
        see. With only that 1 line, we can create users, store them in
        the database, find them again, edit or get rid of them. Wow!
      </p>

      <p class="incremental">
        Sure would be nice if we could see what attributes our User
        objects have without having to look in the database. 
      </p>

      <p class="incremental">
        We can, using the annotate gem. Do the following:
      </p>

      <pre class="incremental">
  # Edit your Gemfile 
  gem "annotate", :group => :development
  bundle install
  bundle exec annotate --position before
  # Now look at your user.rb model file. Much better!      </pre>
    </div>

    <div class="slide">
      <h1>Validations</h1>

      <p>
        Let's also add some data validations:
      </p>
      <pre>
  class User < ActiveRecord::Base
    attr_accessible :name, :email
    validates :name, :presence => true
  end      </pre>

      <p>
        With that restriction, we get automatic testing of it whenever
        we try to save the record - and a number of convenience
        methods such as <code>a_user.valid?</code> and
        <code>a_user.errors.full_messages</code> 
      </p>

      <pre>
# full set of validations we want
  email_regex = /\A[\w+\-.]+@[a-z\d\-.]+\.[a-z]+\z/i

  validates :name,  :presence => true,
                    :length   => { :maximum => 50 }
  validates :email, :presence => true,
                    :format   => { :with => email_regex },
		    :uniqueness => { :case_sensitive => false } </pre>

<pre>
# add unique index on email
rails generate migration add_email_uniqueness_index

class AddEmailUniquenessIndex < ActiveRecord::Migration
  def self.up
    add_index :users, :email, :unique => true
  end

  def self.down
    remove_index :users, :email
  end
end   </pre>
    </div>

    <div class="slide">
      <h1>User's home page</h1>

      <p>
        Let's make a page to show what we know about a user. The rails
        default for such a page is called show:
      </p>

      <pre>
class UsersController < ApplicationController
  def show
    @user = User.find(params[:id])
  end
...
end    </pre>

      <p>
        And we should create the file
        app/views/users/show.html.erb. Hmmm but it still doesn't work
        because there is no route. Let's add the following - and then
        use <code>rake routes</code> to see what that did.
      </p>

      <pre>
  resources :users  </pre>
    </div>

    <div class="slide">
      <h1>Password Fields</h1>

      <p>
        So we created some users - but without passwords how do I know
        you are who you say you are? 
      </p>

      <p>
        A password and password confirmation field are pretty standard
        for most signup forms on the web. But we don't want to store
        the password confirmation - in fact we don't really want to
        store the password, at least not the way you typed it in. For
        security, it should be encrypted. So what we need are some
        "virtual attributes". (From the point of view of the User
        class, they are real attributes but from ActiveRecord's
        perspective, they aren't.)
      </p>

      <pre>
attr_accessor :password

# Automatically create the virtual attribute 'password_confirmation'.
validates :password, :presence     => true,
                     :confirmation => true,
                     :length       => { :within => 6..40 }      </pre>
    </div>

    <div class="slide">
      <h1>Password Migration</h1>

      <p>
        OK but where are we going to store the password? In a field
        called encrypted_password. (We'll show you how the password
        you type in becomes an encrypted password in a minute.)
      </p>

      <pre>
rails generate migration add_password_to_users encrypted_password:string      </pre>

      <p>
        Look at the generated migration file. Impressive, yes? That is
        rail's "Convention over Configuration" at work.
      </p>

      <pre>
class AddPasswordToUsers < ActiveRecord::Migration
  def self.up
    add_column :users, :encrypted_password, :string
  end

  def self.down
    remove_column :users, :encrypted_password
  end
end  </pre>
    </div>

    <div class="slide">
      <h1>Saving the Encrypted Password</h1>

      <p>
        So we have validated our password and password confirmation
        fields. But how do we store the password into the
        encrypted_password field? We'll use an ActiveRecord callback
        to automate this process:
      </p>

      <pre>
class User < ActiveRecord::Base
...
  before_save :encrypt_password

  private

    def encrypt_password
      self.encrypted_password = encrypt(password)
    end

    def encrypt(string)
      string # Only a temporary implementation!
    end
end      </pre>
  
      <p>
        Note the keyword "private" and assignment using self.encrypted_password.
      </p>
    </div>

    <div class="slide">
      <h1>Checking the Password</h1>

      <p>
        So ignore for now that we are not really encrypting
        passwords. How will we check the password you supply on a
        login form? 
      </p>

      <pre>
  # Encrypt the password you just submitted and compare it to the encrypted one
  def has_password?(submitted_password)
    encrypted_password == encrypt(submitted_password)
  end      </pre>
    </div>

    <div class="slide">
      <h1>Password Encryption</h1>

      <p>
        The standard way of storing passwords is to use a one-way
        hash. One way means that you can't deduce the password from
        knowing the encrypted password. However with enough time, you
        can compute likely hashes and compare them until you find a
        match. To make that harder, it is recommended to use a salt -
        an extra piece of data that gets encrypted with the password.
      </p>

      <p>
        So let's start by creating a column for the salt:
      </p>

      <pre>
  rails generate migration add_salt_to_users salt:string      </pre>
      
      <p>
        Now for the full encryption functions:
      </p>

      <pre>
    def encrypt_password
      self.salt = make_salt unless has_password?(password)
      self.encrypted_password = encrypt(password)
    end

    def encrypt(string)
      secure_hash("#{salt}--#{string}")
    end

    def make_salt
      secure_hash("#{Time.now.utc}--#{password}")
    end

    def secure_hash(string)
      Digest::SHA2.hexdigest(string)
    end      </pre>
    </div>

    <div class="slide">
      <h1>User Authentication</h1>

      <p>
        So to authenticate a user, we need to look up the user record,
        grab the salt, encrypt the supplied password, and compare it
        to the one the user just typed in. Not terribly complex - but
        wouldn't it be nice to have that available as a single action
        so you don't have to repeat those steps everywhere you want to
        check on a user? Let's make a method to do that.
      </p>

      <p>
        The methods we have created up to this point have been
        instance methods - they act on a particular user. But we don't
        have a specific user yet - that's what we are trying to figure
        out. So we'll need a class method.
      <p>

      <pre>
class User < ActiveRecord::Base

  def self.authenticate(email , submitted_password)
    user = find_by_email(email)
    return nil  if user.nil?  # no user with that email
    return user if user.has_password?(submitted_password)
  end
end

# To use this:
@user = User.authenticate(email, password)      </pre>
    </div>

    <div class="slide">
      <h1>Gravatars</h1>

      <p>
        Let's spruce up our user display page a bit. Have you seen
        blog comments where the comment had someone's picture next to
        it? Fancy, huh? But actually pretty simple because there is a
        web service you can use to add those images to your pages: <a
        href="http://en.gravatar.com/">http://en.gravatar.com/</a> 
      </p>

      <p>
        A quick look at the <a
        href="http://en.gravatar.com/site/implement/hash/">Gravatar
        instructions</a> show it isn't very complicated to use the
        server. But in the Rails ecosystem it is even easier: there's
        a gem for that!
      </p>

      <pre>
  # Edit your gem file:
  gem 'gravatar_image_tag'

  bundle install

  # in app/views/users/show.html.erb
  <%= gravatar_image_tag 'example@railstutorial.org' %>      </pre>

      <p>
        Also add the user sidebar (section 7.3.3) and augement the stylesheet.
      </p>
    </div>

    <div class="slide">
      <h1>Signup Form</h1>

      <p>
        Standard web form behavior is to return error messages next to
        the field that has the bad data in it - without losing any of
        the other data you have entered into the form. Doing that by
        hand is tedious. Rails takes the drudgery out of that with
        <code>form_for</code> and a handful of form helpers like
        <code>text_field</code>.
      </p>

      <pre>
# app/views/users/new.html.erb
&lt;h1&gt;Sign up&lt;/h1&gt;

&lt;%= form_for(@user) do |f| %&gt;
  &lt;div class="field"&gt;
    &lt;%= f.label :name %&gt;&lt;br /&gt;
    &lt;%= f.text_field :name %&gt;
  &lt;/div&gt;
  &lt;div class="field"&gt;
    &lt;%= f.label :email %&gt;&lt;br /&gt;
    &lt;%= f.text_field :email %&gt;
  &lt;/div&gt;
  &lt;div class="field"&gt;
    &lt;%= f.label :password %&gt;&lt;br /&gt;
    &lt;%= f.password_field :password %&gt;
  &lt;/div&gt;
  &lt;div class="field"&gt;
    &lt;%= f.label :password_confirmation, "Confirmation" %&gt;&lt;br /&gt;
    &lt;%= f.password_field :password_confirmation %&gt;
  &lt;/div&gt;
  &lt;div class="actions"&gt;
    &lt;%= f.submit "Sign up" %&gt;
  &lt;/div&gt;
&lt;% end %&gt;      </pre>

      <pre>
# app/controllers/users_controller.rb
  def new
    @user = User.new  # need this for form_for to act on
    @title = "Sign up"
  end  </pre>

    </div>

    <div class="slide">
      <h1>Signup Form 2</h1>

      <p>
        Now let's look at the html generated by form_for and friends:
      </p>
      
      <pre>
# Form fields. Note the generated name
&lt;input id="user_name" name="user[name]" - - - /&gt;

# And the form definition itself:
&lt;form action="/users" class="new_user" id="new_user" method="post"&gt;
&lt;div style="margin:0;padding:0;display:inline"&gt;
&lt;input name="authenticity_token" type="hidden"
       value="rB82sI7Qw5J9J1UMILG/VQL411vH5putR+JwlxLScMQ=" /&gt;
&lt;/div&gt;      </pre>

      <p>
        So when we submit the form, where will it end up? Let's check
        our routes:
      </p>

      <pre>
$ rake routes
    users GET    /users(.:format)          {:action=>"index",  :controller=>"users"}
          POST   /users(.:format)          {:action=>"create", :controller=>"users"}
 new_user GET    /users/new(.:format)      {:action=>"new",    :controller=>"users"}
edit_user GET    /users/:id/edit(.:format) {:action=>"edit",   :controller=>"users"}
     user GET    /users/:id(.:format)      {:action=>"show",   :controller=>"users"}
          PUT    /users/:id(.:format)      {:action=>"update", :controller=>"users"}
          DELETE /users/:id(.:format)      {:action=>"destroy", :controller=>"users"}      </pre>
    </div>

    <div class="slide">
      <h1>Create a User</h1>

      <pre>
class UsersController < ApplicationController
  def create
    @user = User.new(params[:user])
    if @user.save
      redirect_to @user
    else
      @title = "Sign up"
      render 'new'
    end
  end
end  </pre>

    </div>

    <div class="slide">
      <h1>Error Handling </h1>

      <p>
        Recall that ActiveRecord gives you an array of error messages
        - everything that is wrong with the user you tried to create:
	<code>a_user.errors.full_messages</code> So how can we show
        those to the user? 
      </p>

      <pre>
# make a partial app/views/shared/_error_messages.html.erb
&lt;% if @user.errors.any? %&gt;
  &lt;div id="error_explanation"&gt;
    &lt;h2&gt;&lt;%= pluralize(@user.errors.count, "error") %&gt; 
        prohibited this user from being saved:&lt;/h2&gt;
    &lt;p&gt;There were problems with the following fields:&lt;/p&gt;
    &lt;ul&gt;
    &lt;% @user.errors.full_messages.each do |msg| %&gt;
      &lt;li&gt;&lt;%= msg %&gt;&lt;/li&gt;
    &lt;% end %&gt;
    &lt;/ul&gt;
  &lt;/div&gt;
&lt;% end %&gt;      </pre>
      
      <p>
        Ruby goodness: .any?, .each do |msg| end. Rails goodness: pluralize
      </p>
    </div>

    <div class="slide">
      <h1>Flash Notices</h1>

      <p>
        When user creation succeeds, the user gets redirected to their
        user page. But perhaps we would like to set a temporary
        message on that first page view. For example: "Welcome! You
        can now start posting!" Rails provides a way to add a
        temporary message for the very next page view - called the flash.
      </p>

      <pre>
# To create them:
  # In app/controllers/users_controller.rb
  flash[:success] = "Welcome to the Sample App!"
      </pre>

      <pre>
# To display them
  # In app/views/layouts/application.html.erb
  &lt;% flash.each do |key, value| %&gt;
    &lt;div class="flash &lt;%= key %&gt;"&gt;&lt;%= value %&gt;&lt;/div&gt;
  &lt;% end %&gt;      </pre>
    </div>

    <div class="slide">
      <h1>User Sessions</h1>

      <p>
        You can look at being logged in or not as an attribute of the
        user. But Rails prefers to think of logging in as "creating a
        new session" and logging out as "destroying a session". So the
        usual way to implement user log-ins in Rails is to create a
        Session controller. 
      </p>

      <pre>
  rails generate controller Sessions new      </pre>

      <p>
        We will also need actions for create and destroy - but they
        won't need views, so we'll just add them by hand later. We
        will need some routes - and will probably want them to have
        pretty names.
      </p>

      <pre>
SampleApp::Application.routes.draw do
  resources :users
  resources :sessions, :only => [:new, :create, :destroy]

  match '/signup',  :to => 'users#new'
  match '/signin',  :to => 'sessions#new'
  match '/signout', :to => 'sessions#destroy'
...      </pre>

    </div>

    <div class="slide">
      <h1>Sign In Form</h1>

      <p>
        So to sign in, we'll need a form that is similar to our signup
        form - except we'll only need email and password. The other
        main difference is that we don't have a database model for the
        session (it's data is stored in a session cookie on your
        browser). So we'll need to use form_for a little differently:
      </p>

      <pre>
  # instead of 
  form_for(@user)

  # we need to tell form_for the name of the resource and a target url
  form_for(:session, :url => sessions_path)          </pre>

      <pre>
# app/views/sessions/new.html.erb
&lt;h1&gt;Sign in&lt;/h1&gt;

&lt;%= form_for(:session, :url =&gt; sessions_path) do |f| %&gt;
  &lt;div class="field"&gt;
    &lt;%= f.label :email %&gt;&lt;br /&gt;
    &lt;%= f.text_field :email %&gt;
  &lt;/div&gt;
  &lt;div class="field"&gt;
    &lt;%= f.label :password %&gt;&lt;br /&gt;
    &lt;%= f.password_field :password %&gt;
  &lt;/div&gt;
  &lt;div class="actions"&gt;
    &lt;%= f.submit "Sign in" %&gt;
  &lt;/div&gt;
&lt;% end %&gt;

&lt;p&gt;New user? &lt;%= link_to "Sign up now!", signup_path %&gt;&lt;/p&gt;      </pre>

    </div>

    <div class="slide">
      <h1>Sign In Form 2</h1>

      <p class="incremental">
        So what is the usual logic for form submission?
      </p>

      <p class="incremental">
        We saw how to implement that with form_for and an ActiveRecord
        model (validations, error reporting, etc.). So how do we do
        that with our session form? 
      </p>

      <p class="incremental">
        We use our User.authenticate action
      </p>
      
      <pre class="incremental">
  def create
    user = User.authenticate(params[:session][:email],
                             params[:session][:password])
    if user.nil?
      # Create error messages and rerender new
      flash.now[:error] = "Invalid email/password combination."
      @title = "Sign in"
      render 'new'
    else
      # set session cookie and redirect user to his own page
    end
 end      </pre>
    </div>

    <div class="slide">
      <h1>Session Cookies</h1>

      <p>
        The most common way of keeping track of user sessions is to
        use browser cookies. Rails has machinery for creating
        encrypted cookies and allowing you to easily store data in and
        retrieve data from the cookie. We are going to reuse the salt
        we created to encrypt each user's password to encrypt their
        user id before storing it in a cookie named "remember_token".
      </p>

      <pre>
  def sign_in(user)
    cookies.permanent.signed[:remember_token] = [user.id, user.salt]
    self.current_user = user
  end      </pre>

      <p>
        For more details on security threats and how to use Rails to
        counter them, see the <a
        href="http://guides.rubyonrails.org/security.html">Rails
        Security Guide</a>.
      </p>
    </div>

    <div class="slide">
      <h1>Session Cookies 2</h1>

      <p>
        But where does the code above go? We will need it in our
        controllers and in our views. Views already load all helper
        methods - and we can easily load the SessionHelper module in
        our application controller. 
      </p>

      <pre>
module SessionsHelper
  def sign_in(user)
    cookies.permanent.signed[:remember_token] = [user.id, user.salt]
    self.current_user = user
  end
end 

class ApplicationController &lt; ActionController::Base
  protect_from_forgery
  include SessionsHelper
end      </pre>

    </div>

    <div class="slide">
      <h1>Current User</h1>

      <p class="incremental">
        In the previous step, we created a current_user attribute in
        the session. Or did we? We haven't created a setter method for
        current_user. There isn't an attr_write nor an current_user=
        method. We better create one - and create a getter method
        while we are at it. 
      </p>

      <pre class="incremental">
  def current_user=(user)
    @current_user = user
  end </pre>

      <p class="incremental">
        You might think we coudl just create a getter that returns
        @current_user. However, since that is an instance variable,
        you would get a different instance for every page request. Not
        very helpful if you are trying to preserve state across
        multiple page requests.
      </p>

      <pre class="incremental">
  def current_user
    @current_user ||= user_from_remember_token
  end

  private

    def user_from_remember_token
      User.authenticate_with_salt(*remember_token)
    end

    def remember_token
      cookies.signed[:remember_token] || [nil, nil]
    end

      </pre>
    </div>


  </body>
</html>
