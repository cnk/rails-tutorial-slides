<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-US">
  <head>
    <meta name="generator" content="HTML Tidy for Linux/x86 (vers 1st November 2003), see www.w3.org" />
    <title>Rails Tutorial Using Rails 3.0.10</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="copyright" content="Copyright &#169; 2011 The Rubyists http://therubyists.org" />
    <meta name="duration" content="20" />
    <link rel="stylesheet" href="http://www.w3.org/Talks/Tools/Slidy2/styles/slidy.css" type="text/css" />
    <script src="http://www.w3.org/Talks/Tools/Slidy2/scripts/slidy.js" charset="utf-8" type="text/javascript"></script>
  </head>
  <body>
    <div class="slide">
      <h1>Welcome</h1>

      <p>
        Welcome to the LA Ruby Study Group Rails Tutorial Workshop.
      </p>

      <p>
        We are going to work through the Rails Tutorial book. You will
        have already worked through the install steps last
        weekend. Tonight we will be starting right in with Chapter 3 -
        Mostly Static Pages.
      </p>
      
      <p>
        We will be skipping the testing portions of the book. In the
        long run, testing saves time you would spend debugging or
        doing <i>ad hoc</i> testing - but in the short run it takes
        time.
      </p>

    </div>

    <div class="slide">
      <h1>Our Sample App</h1>

      <pre>
  cd _wherever_you_want_to_work_
  rails new sample_app

  app/   - this is where your application lives
     controllers/
     helpers/
     models/
     views/
  config/  - application configuration, e.g. database.yml
  db/migrations/ - database-agnostic schema definition
  log/     - log files. Look here for debugging information
  public/  - images, stylesheets, javascript
  Gemfile  - what gems should we load for this application? 
  .gitignore -  Lists of files we don't want version controlled      </pre>
    </div>

    <div class="slide">
      <h1>Start Your Server</h1>

      <pre>
  cd sample_app
  bundle install
  rails server	
  => Booting WEBrick
  => Rails 3.0.9 application starting on http://0.0.0.0:3000
  => Call with -d to detach
  => Ctrl-C to shutdown server      </pre>

      <p>
        In your web browser, got to <a href="http://localhost:3000">http://localhost:3000</a>
      </p>
    </div>

    <div class="slide">
      <h1>Using Git</h1>

      <p>
        Version control is a good development practice. It is also the
        tool we are going to use to transfer the code you have on your
        local machine to Heroku - a web host where the rest of the
        world can see your handiwork. 
      </p>

      <pre>
  Initial (one time) setup: 
  git config --global user.name "Your Name"
  git config --global user.name "Your Name"

  git init
  # Possibly edit the .gitignore file
  git add . 
  git commit -m "Bare rails project"      </pre>
    </div>

    <div class="slide">
      <h1>Deploy</h1>

      <p>
        Everyone signed up for a free Heroku account, right? <a
        href="https://api.heroku.com/signup">https://api.heroku.com/signup</a> 
      </p>

      <pre>
  gem list heroku

  heroku keys:add
  heroku create
  git push heroku master

  heroku open      </pre>
      <p>
        Don't worry about the fact the "About your application's
        environment" link doesn't work on Heroku. That's normal. We'll
        be replacing that page with something more interesting soon.
      </p>
    </div>

    <div class="slide">
      <h1>Static Pages</h1>

      <p>
        Any page or file placed within the public/ directory will be
        served directly from that location without passing through the
        rails routing system. For example, let's create a file
        public/hello.html
     </p>

     <p>
       That's nice. But it has all the disadvantages of a static web
       page. For example, it must contain all of the styling
       information for the page. And if that changes, it needs to be
       changed on every page. That violates one of Rails' guiding
       principles: <b>Don't Repeat Yourself</b>
     </p>

      <p>
        Rails can offer you a better option - using the Rails
        templating system to apply a common layout. 
      </p>
    </div>

    <div class="slide">
      <h1>Not Really Static Pages</h1>

      <pre>
  rails generate controller Pages home contact      
      create  app/controllers/pages_controller.rb
       route  get "pages/contact"
       route  get "pages/home"
      invoke  erb
      create    app/views/pages
      create    app/views/pages/home.html.erb
      create    app/views/pages/contact.html.erb      </pre>

      <p>
        This will have generated a controller named Pages and added 2
        actions to it: home and contact. It has also added routes and pages.
	Let's look at them.
      </p>
    </div>

    <div class="slide">
      <h1>Common Layout</h1>

      <p>
        Let's take advantage of the site layout file. Let's add a
        title to each page.
      </p>

      <pre>
  class PagesController < ApplicationController
    def home
      @title = "Home"
    end
  end      </pre>

      <p>
        Views: html + ruby. The text between &lt;% and %&gt; is
        evaluated as ruby. If there is an equal sign, the result of
        the ruby is placed in the html:  &lt;%= 2+2 %&gt; yields
        4. The value of instance variables can be placed in a view.
      </p>

      <pre>
  &lt;title&gt;&lt;%= @title %&gt;&lt;/title&gt;     </pre>
    </div>

    <div class="slide">
      <h1>A Sliver of Ruby</h1>

      <pre>
  module ApplicationHelper

    # Return a title on a per-page basis.
    def title
      base_title = "Ruby on Rails Tutorial Sample App"
      if @title.nil?
	base_title
      else
	"#{base_title} | #{@title}"
      end
    end
  end  </pre>

      <ul>
        <li>How to define methods, variables, and comments</li>
        <li>if-else-end syntax</li>
	<li>foo.nil?  (Rails also gives you foo.blank?)</li>
	<li>String interpolation: "#{variable} plus litteral text"
	<li>Application Helper methods are available in all views on
        your site</li>
      </ul>
    </div>

    <div class="slide">
      <h1>A Bit More Ruby</h1>

      <pre>
  # Array's 
  a = [23, 43, "foo", "zombies"]
  puts a[0] 
  => 23
  a.length 
  => 4

  # Hashes
  user = { "first_name" => "Michael", "last_name" => "Hartl" }
  user["last_name"]
  => "Hartl"
  user["email"]
  => nil

  # Hashes with symbols
  user = { :first_name => "Michael", :last_name => "Hartl" }
  user[:first_name]
  => "Hartl"      </pre>

    </div>

    <div class="slide">
      <h1>Styling with Blueprint CSS</h1>

      <p>
        Download the latest version of Blueprint CSS from <a
        href="http://www.blueprintcss.org/">http://www.blueprintcss.org/</a>
        Unzip or untar it. Then copy the subdirectory "blueprint" into
        your public/stylesheets/ directory.
      </p>

      <pre>
  cd joshuaclayton-blueprint-css-*version number*        
  cp -r blueprint $RAILS_ROOT/public/stylesheets/   
  cd $RAILS_ROOT
  ls public/stylesheets
  blueprint/ 

  # Edit your application layout file to add the screen and print
  styles - and take care of a few IE issues:
  &lt;html&gt;
    &lt;head&gt;
      &lt;title&gt;&lt;%= @title %&gt;&lt;/title&gt;
      &lt;%= csrf_meta_tag %&gt;
      &lt;!--[if lt IE 9]&gt;
      &lt;script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"&gt;&lt;/script&gt;
      &lt;![endif]--&gt;    
      &lt;%= stylesheet_link_tag 'blueprint/screen', :media =&gt; 'screen' %&gt;
      &lt;%= stylesheet_link_tag 'blueprint/print',  :media =&gt; 'print' %&gt;
      &lt;!--[if lt IE 8]&gt;&lt;%= stylesheet_link_tag 'blueprint/ie' %&gt;&lt;![endif]--&gt;
      &lt;%= stylesheet_link_tag 'custom', :media =&gt; 'screen' %&gt;
    &lt;/head&gt; </pre>
    </div>

    <div class="slide">
      <h1>Spicing Up Your Application Layout</h1>

      <p>
        Let's start by looking at Michael's <a
        href="http://railstutorial.org/images/figures/home_page_mockup-full.png">wireframe</a>.
	So, there is going to be a logo at the top - and some standard
        links in the upper left. Let's put those in. 
      </p>
      <p>
        First, let's copy the logo from <a
        href="http://railstutorial.org/images/sample_app/logo.png">http://railstutorial.org/images/sample_app/logo.png</a>
	Place that in your public/images directory. Then use the image
        tag to put it into your page:
      </p>
      <pre>
<%= image_tag("logo.png", :alt => "Sample App", :class => "round") %>        </pre>

      <p>
        And add the links at the top of the page:
      </p>
      <pre>
  &lt;nav class="round"&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;%= link_to "Home", '#' %&gt;&lt;/li&gt;
      &lt;li&gt;&lt;%= link_to "Help", '#' %&gt;&lt;/li&gt;
      &lt;li&gt;&lt;%= link_to "Sign in", '#' %&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/nav&gt;       </pre>
    </div>

    <div class="slide">
      <h1>Routes</h1>

      <p>
        "Normal" web sites serve pages from subdirectories of the
        document root. Rails uses this style of url <-> file matching
        for items under <code>public/</code>. But for the most part
        urls are matched to controllers using routes configured in
        <code>config/routes.rb</code>
      </p>
      
      <pre>
SampleApp::Application.routes.draw do
  match '/contact', :to => 'pages#contact'
  match '/about',   :to => 'pages#about'
  match '/help',    :to => 'pages#help'

  root :to => 'pages#home'
end  </pre>

     <p>
       To reference those routes, don't use the url form ('/about')
       use the helper functions: about_path or about_url.
     </p>

     <pre>
&lt;%= link_to "About", about_path %&gt;  </pre>

    </div>

    <div class="slide">
      <h1>Partials</h1>

      <p>
        OK things are starting to look pretty good. We have everything
        except the footer in place. But have you noticed how
        complicated the layout file is starting to look? That big
        block of stylesheet references is a lot of verbage for
        something so simple. Let's hide that complexity from
        application.html.erb by putting it in its own file. 
      </p>
      
      <pre>
  <%= render "layouts/stylesheets" %>      
  
  # inserts the html from app/views/layouts/_stylesheets.html.erb   </pre>

      <p>
        Let's do the same for our header and footer.
      </p>
    </div>

    <div class="slide">
      <h1>Sign up now!</h1>

      <p>
        Now for that big green button. Sign up is the same thing as
        making a new user. Let's make a new controller for users -
        with an action to create a new user. 
      </p>
      
      <pre>
  rails generate controller Users new      </pre>

      <p>
        That doesn't really do anything yet - but it should
        work. Let's edit the sign up link. But what is the name of the
        new user route that was added?
      </p>

      <pre>
  rake routes
  users_new GET /users/new(.:format) {:controller=>"users", :action=>"new"}
    contact     /contact(.:format)   {:controller=>"pages", :action=>"contact"}
      about     /about(.:format)     {:controller=>"pages", :action=>"about"}
       help     /help(.:format)      {:controller=>"pages", :action=>"help"}
       root     /(.:format)          {:controller=>"pages", :action=>"home"}      </pre>

       <p>
         So we could use users_new_path OR we can add a named route: 
       </p>
      <pre>
  match '/signup', :to => users#new'  </pre>
    </div>

    <div class="slide">
      <h1>User Modeling</h1>

      <p>
        Rails now supports several different methods of storing data -
        but the default is still ActiveRecord - an ORM (object
        relational mapper) that can store data in any one of several
        types of databases. 
      </p>

      <pre>
  rails generate model User name:string email:string  </pre>

      <p>
        Notice models are singular, controllers (and table names) are
        plural. 
      </p>

      <p>
        Look at the migration file. Data definition in bite-sized
        steps - and in ruby so they are database agnositic (as long as
        you don't need a specialized feature of your database). Notice
        <code>t.timestamps</code> - that adds special columns to your
        table: updated_at and created_at. Callbacks will updated those
        automatically when a record is created or updated.
      </p>

      <pre>
  class CreateUsers < ActiveRecord::Migration
    def self.up
      create_table :users do |t|
	t.string :name
	t.string :email

	t.timestamps
      end
    end

    def self.down
      drop_table :users
    end
  end  </pre>

      <pre>
  bundle exec rake db:migrate   </pre>

      <p>
        Let's look at the table using either <a
        href="http://sqlitebrowser.sourceforge.net/">SQLite Database
        Browser</a> or the Firefox <a
        href="https://addons.mozilla.org/en-US/firefox/addon/sqlite-manager/">SQlite
        Manager</a>. Note the id column is added automatically.
      </p>
    </div>

    <div class="slide">
      <h1>The User Class</h1>

      <p>
        So let's look at the Ruby class that represents our User.
      </p>

      <pre>
  class User < ActiveRecord::Base
  end      </pre>

      <p>
        But there's nothing there?! Does it do anything yet? Yes,
        actually it does. Let's break out the rails console and
        see. With only that 1 line, we can create users, store them in
        the database, find them again, edit or get rid of them. Wow!
      </p>

      <p class="incremental">
        Sure would be nice if we could see what attributes our User
        objects have without having to look in the database. 
      </p>

      <p class="incremental">
        We can, using the annotate gem. Do the following:
      </p>

      <pre class="incremental">
  # Edit your Gemfile 
  gem "annotate", :group => :development
  bundle install
  bundle exec annotate --position before
  # Now look at your user.rb model file. Much better!      </pre>
    </div>

    <div class="slide">
      <h1>Validations</h1>

      <p>
        Let's also add some data validations:
      </p>
      <pre>
  class User < ActiveRecord::Base
    attr_accessible :name, :email
    validates :name, :presence => true
  end      </pre>

      <p>
        With that restriction, we get automatic testing of it whenever
        we try to save the record - and a number of convenience
        methods such as <code>a_user.valid?</code> and
        <code>a_user.errors.full_messages</code> 
      </p>

      <pre>
# full set of validations we want
 email_regex = /\A[\w+\-.]+@[a-z\d\-.]+\.[a-z]+\z/i

 validates :name,   :presence => true,
                    :length   => { :maximum => 50 }
  validates :email, :presence => true,
                    :format   => { :with => email_regex },
		    :uniqueness => { :case_sensitive => false } </pre>

<pre>
# add unique index on email
rails generate migration add_email_uniqueness_index

class AddEmailUniquenessIndex < ActiveRecord::Migration
  def self.up
    add_index :users, :email, :unique => true
  end

  def self.down
    remove_index :users, :email
  end
end   </pre>
    </div>

    <div class="slide">
      <h1>User's home page</h1>

      <p>
        Let's make a page to show what we know about a user. The rails
        default for such a page is called show:
      </p>

      <pre>
class UsersController < ApplicationController
  def show
    @user = User.find(params[:id])
  end
...
end    </pre>

      <p>
        And we should create the file
        app/views/users/show.html.erb. Hmmm but it still doesn't work
        because there is no route. Let's add the following - and then
        use <code>rake routes</code> to see what that did.
      </p>

      <pre>
  resources :users  </pre>
    </div>

  </body>
</html>
